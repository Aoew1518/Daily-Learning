# DNS 解析 IP地址
1. 客户端从本地服务器查找IP
2. 再去根域名服务器查找
3. 再去顶级域名服务器查找
4. 再去目标服务器
5. 找到了IP地址就IP缓存进本地DNS缓存区

# TCP 三次握手
- 可靠性高
  1. 超时重传 (TCP会备份数据包)
  2. 拥塞控制
  3. 丢包重传 (有序性)
- 效率低

- 三次握手
  1. 客户端给服务端发送建立链接的请求 SYN-SENT 状态
  2. 服务器向客户端发送已收到请求的应答 SYN-received 状态
  3. 客户端接受到3同意链接应答后，再发送一次确认请求，双方进入 ESTABLISHED 状态
  
- 为什么俩次握手不行？
  不行，假设客户端给服务端发送了一个建立连接请求A，但是因为网络环境差，这个请求A超时了，那么TCP会启动超时重传机制，再发送一个新的建立连接请求B，服务端接受到B请求后应答，如果此时就完成了建立连接的话，当客户端和服务端通信完成后，便释放了连接，双方都进入Closed状态。假设此时A请求又抵达了服务端，那么服务端会认为客户端又要建立新的链接从而应答该请求并进入ESTABLISHED状态，而此时客户端是Closed状态，那么服务端就会一直等待，造成资源浪费。

- HTTP数据传输


- 四次挥手
  1. 客户端请求完数据后向服务端发送断开连接请求
  2. 服务端接收到断开连接请求后，通知应用层去释放TCP连接，此时不再接受客户端的请求了
  3. 服务端如果还有没有发送完的数据会继续发送，完毕后会向客户端发送释放连接的应答
  4. 客户端接收到释放连接的应答后，向服务端发送确认释放连接的应答

# UDP
 - 不可靠
    1. 不需要建立连接
    2. 以恒定速率发包
    3. 不会给数据包拼接过多的字段
    4. 没有拥塞控制

 - 不安全但是效率高

 - 应用场景
    游戏，直播，音视频通话

# 浏览器获取到服务端资源后
 - 解析 HTML 资源生成DOM树
    1.浏览器接收到的是二进制的字节数据，浏览器会将这些二进制的数据转换成字符串
    2.对字符串进行词法分析

 - 解析 css 资源生成 CSSM树

 - 合并DOM树和CSSOM树，生成render树
  1. 只会包含需要显示的节点
  2. 根据渲染树来布局页面（回流）
  3. GPU绘制，合成图层，显示在页面上（重绘）

# 回流
- 修改一个元素的集合属性会导致回流
  1. 修改宽高
  2. 页面初次渲染
  3. 添加、删除元素
  4. 改变窗口大小

# 重绘
- 回流一定重绘

# 浏览器的优化策略
  - 当我们修改一个元素的集合属性导致浏览器需要回流时，浏览器会维护一个渲染队列，将需要回流的操作存入队列，等到后续没有回流行为达到阈值时会一次性将队列中的行为全部执行
  offsetXXX
  clientXXX
  会导致渲染队列强制刷新

# js 加载执行会阻塞html的渲染
  1. 在script标签上加 async ，该js的加载就不会阻塞html的渲染

# js 操作DOM慢？
  1. DOM 结构在js引擎眼里有很庞大的属性
  2. js引擎线程和渲染线程是互斥的
  