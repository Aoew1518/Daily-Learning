# 1.说说+你对vue的理解
 - 是什么
    是一个js框架，用于创建一个单页应用的web应用框架，主旨的为了简化web的开发，主要靠MVVM的驱动方式来实现试图的更新
 - 特性
    1. MVVM (Model View ViewModel)
     1). Model --- 模型层 (模板，业务逻辑的代码)
     2). View --- 视图层 (html页面)
     3). ViewModel --- 试图模型层 (用于将模型和试图进行通信链接)
    
    2. 组件化
     1). 代码复用
     2). 降低整体耦合度

    3. 指令
     1). 大大减少了Dom的操作

# 2.说说你对SPA单页应用的理解
 - 是什么
   只有一个 HTML 页面，本质上只需要控制某一个代码片段被拿到html中生效而已

 - 特点
   页面在任何时候都不会重新加载，不会打断用户体验

 - 缺点
   存在首屏加载时间过长的情况
   不利于搜索引擎的抓取
 
 - 解决首屏加载过慢的手段：
   1. 路由的懒加载
   2. ssr (服务器渲染：在vue项目中再启动一个node服务，负责直接响应首页的代码片段，项目其他的代码片段依然保持原有的加载方式，这样就能让用户第一时间看到首页)
·
# 3.说说你对双向绑定的理解
 - 是什么
   模板层的数据变更会导致视图层的更新，视图层的数据更新也会导致模板层的数据改变

 - 原理 (ViewModel的原理)
   1. 监听器：对所有的数据进行更新
   2. 解析器：对每个元素节点的指令进行解析

 - 双向绑定的理解：
   1. vue的数据源会被劫持，在劫持过程中为属性做依赖收集，vue中的观察者watcher负责更新视图，依赖收集到的是观察者watcher的实例对象。当属性值发生变更时会触发依赖，进而触发试图更新函数
   2. 在数据劫持的同时，vue会编译模块，解析指令，当试图层的数据发生变更时，编译器中绑定的函数会被触发，进而获取到最新的数据值，再次通知Watcher去触发依赖

# 4.vue的生命周期
1. **beforeCreate**: 实例刚被创建，属性 `data`、`methods` 等还未初始化，此时不能访问 `data` 和 `methods` 中的数据和方法。
2. **created**: 实例已经创建完成，可以访问属性 `data`，也可以通过 `this.method()` 访问方法。但是不能操作 DOM。
3. **beforeMount**: 模板编译/挂载之前调用，此时虚拟 DOM 已经准备就绪。
4. **mounted**: 实例已经挂载到 DOM 上，可以进行 DOM 操作。如果需要和后端交互，最好在这个阶段发起请求。
5. **beforeUpdate**: 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。
6. **updated**: 数据更新导致虚拟 DOM 重新渲染和打补丁之后调用。
7. **beforeUnmount**: 实例被销毁前调用，在这一步，实例仍然完全可用。
8. **unmounted**: Vue 实例销毁后调用，清理工作应该在这里进行。
  - keep-alive
1. **activated**: 当被 `<keep-alive>` 缓存的组件被激活时调用，即组件从缓存中加载到 DOM 中时触发。
2. **deactivated**: 当被 `<keep-alive>` 缓存的组件被停用时调用，即组件从 DOM 中移除时触发。

# 5. 组件传值
1. 父子通信 子组件props接受
2. 子父通信 子组件 emit 发布一个事件，父组件订阅该事件
3. 子父通讯 子组件拿到父组件的数据并修改后emit出来，父组件靠v-model实现双向绑定
4. 子夫通信 子组件defineExpose暴露出来值，父组件利用ref读取整个子组件对象来获取值
5. 父子通信 父组件 provide 子组件 inject
6. EventBus mitt插件
7. vuex || pinia

# 6. v-if 和 v-for 共存吗？

# 7. 为什么data用函数而不用对象的形式？

